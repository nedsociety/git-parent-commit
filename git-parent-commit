#!/usr/bin/env -S uv --quiet run --script
# /// script
# requires-python = ">=3.8"
# dependencies = [
#   "typer[all]>=0.9.0",
#   "loguru>=0.7.0",
# ]
# ///

"""
Finds the latest commit in a parent repository that is compatible
with a specific version of a submodule repository.

This script finds a parent commit that changes the submodule reference from X to Y,
where X is the target submodule commit or one of its ancestors, and Y is a descendant
of the target. The result is the commit right before that transition (the last
unchanged commit).

If P-paths are specified, only descendants that change those paths are considered
as valid Y values.
"""

# This script is managed by `uv` per the header above.
# To run it, `uv` will automatically create a virtual environment
# and install dependencies if needed.

import subprocess
import sys
import typer
from pathlib import Path
from typing import List, Set, Optional
from loguru import logger

# Configure logger to output to stderr
logger.remove()
logger.add(sys.stderr, format="{level.icon} {message}", level="INFO")

# Create the app
app = typer.Typer()

def run_git_command(command: List[str], cwd: Path) -> str:
    """
    Runs a Git command in a specified directory and returns its stdout.
    Raises an exception if the command fails.
    """
    try:
        # logger.debug(f"Running: {' '.join(command)} in {cwd}")
        result = subprocess.run(
            command,
            cwd=cwd,
            check=True,
            capture_output=True,
            text=True,
            encoding='utf-8'
        )
        return result.stdout.strip()
    except subprocess.CalledProcessError as e:
        logger.error(f"Error running command: {' '.join(command)}")
        logger.error(f"Working Directory: {cwd}")
        logger.error(f"Return Code: {e.returncode}")
        logger.error(f"Stdout: {e.stdout}")
        logger.error(f"Stderr: {e.stderr}")
        raise
    except FileNotFoundError:
        logger.critical(f"Error: 'git' command not found. Is Git installed and in your PATH?")
        raise

def is_ancestor_of(
    repo_path: Path,
    ancestor: str,
    descendant: str
) -> bool:
    """
    Checks if commit 'ancestor' is an ancestor of commit 'descendant'.
    Returns True if ancestor is an ancestor of descendant (or they are the same).
    """
    # git merge-base --is-ancestor returns 0 if ancestor is an ancestor
    command = ["git", "merge-base", "--is-ancestor", ancestor, descendant]
    result = subprocess.run(
        command,
        cwd=repo_path,
        capture_output=True,
        text=True,
        encoding='utf-8'
    )
    # Exit code 0 means ancestor is an ancestor (or same commit)
    # Exit code 1 means it's not
    return result.returncode == 0

def is_descendant_of(
    repo_path: Path,
    descendant: str,
    ancestor: str
) -> bool:
    """
    Checks if commit 'descendant' is a descendant of commit 'ancestor'.
    Returns True if descendant is a descendant of ancestor (or they are the same).
    """
    return is_ancestor_of(repo_path, ancestor, descendant)

def descendant_changes_paths(
    repo_path: Path,
    target: str,
    descendant: str,
    paths: Optional[List[str]]
) -> bool:
    """
    Checks if a descendant commit changes the specified paths compared to target.
    If paths is None or empty, returns True (all descendants are valid).
    Returns True if descendant has changes in the specified paths, False otherwise.
    """
    if not paths or paths == ["."]:
        # No path filtering, all descendants are valid
        return True
    
    # Check if there's a diff in the specified paths
    command = ["git", "diff", "--quiet", f"{target}..{descendant}", "--"] + paths
    result = subprocess.run(
        command,
        cwd=repo_path,
        capture_output=True,
        text=True,
        encoding='utf-8'
    )
    # Exit code 0 means no diff (doesn't change paths)
    # Exit code 1 means has diff (changes paths)
    return result.returncode == 1

def get_submodule_commit_at_parent(
    parent_repo_path: Path,
    parent_commit: str,
    submodule_path: str
) -> Optional[str]:
    """
    Gets the submodule commit hash that a parent commit points to.
    Returns None if the submodule path doesn't exist at that commit.
    """
    ls_tree_cmd = ["git", "ls-tree", parent_commit, "--", submodule_path]
    try:
        ls_output = run_git_command(ls_tree_cmd, parent_repo_path)
        if not ls_output:
            return None
        
        # Output format: <mode> <type> <hash> <path>
        parts = ls_output.split()
        if len(parts) < 3:
            return None
            
        return parts[2]
    except subprocess.CalledProcessError:
        # This commit probably doesn't have the submodule path.
        return None

def find_transition_parent_commit(
    parent_repo_path: Path,
    parent_branch: str,
    submodule_path: str,
    submodule_repo_path: Path,
    target_submodule_commit: str,
    submodule_branch: str,
    paths_to_check: Optional[List[str]],
    limit_search_depth: Optional[int]
) -> Optional[str]:
    """
    Finds the latest parent commit that transitions the submodule from X to Y,
    where X is target or ancestor of target, and Y is a descendant of target.
    Returns the commit right before the transition (the last unchanged commit).
    """
    logger.info(f"--- Searching for submodule transition in parent repo ---")
    logger.info(f"Target submodule commit: {target_submodule_commit}")
    logger.info(f"Searching branch '{parent_branch}' in {parent_repo_path}")
    
    # Resolve the target commit to a full hash
    try:
        target_hash = run_git_command(["git", "rev-parse", target_submodule_commit], submodule_repo_path)
    except subprocess.CalledProcessError:
        logger.error(f"Error: Target submodule commit '{target_submodule_commit}' not found in {submodule_repo_path}")
        raise typer.Exit(code=1)
    
    logger.info(f"Full target submodule hash: {target_hash}")

    # Get all commits in Parent, newest to oldest
    parent_commit_list_cmd = ["git", "rev-list", parent_branch]
    parent_commits = run_git_command(parent_commit_list_cmd, parent_repo_path)
    num_parent_commits = len(parent_commits.splitlines())
    logger.info(f"Found {num_parent_commits} parent commits on branch '{parent_branch}'")
    
    if (limit_search_depth is not None) and (limit_search_depth < num_parent_commits):
        logger.info(f"Limiting search to {limit_search_depth} commits")
        parent_commits = parent_commits.splitlines()[:limit_search_depth]
    else:
        logger.info(f"Searching all {num_parent_commits} parent commits")
        parent_commits = parent_commits.splitlines()

    # Iterate through parent commits, checking for transitions
    for parent_commit in parent_commits:
        if not parent_commit:
            continue

        # Get submodule commit at current parent commit
        current_submodule = get_submodule_commit_at_parent(
            parent_repo_path, parent_commit, submodule_path
        )
        if current_submodule is None:
            continue

        # Get the actual parent commit of the current commit
        try:
            prev_parent_commit = run_git_command(
                ["git", "rev-parse", f"{parent_commit}^"],
                parent_repo_path
            )
        except subprocess.CalledProcessError:
            # This commit has no parent (root commit), skip
            continue
            
        prev_submodule = get_submodule_commit_at_parent(
            parent_repo_path, prev_parent_commit, submodule_path
        )
        if prev_submodule is None:
            continue

        # Check if this is a transition from X to Y:
        # X = target or ancestor of target
        # Y = descendant of target (and changes P-paths if specified)
        
        # Check if prev_submodule is target or ancestor of target
        if not is_ancestor_of(submodule_repo_path, prev_submodule, target_hash):
            continue
        
        # Check if current_submodule is descendant of target
        if not is_descendant_of(submodule_repo_path, current_submodule, target_hash):
            continue
        
        # If P-paths specified, check if current_submodule changes those paths
        if not descendant_changes_paths(
            submodule_repo_path, target_hash, current_submodule, paths_to_check
        ):
            continue

        # Found a transition!
        logger.success(f"Found transition:")
        logger.success(f"  Parent commit {parent_commit[:10]}: submodule {prev_submodule[:10]} â†’ {current_submodule[:10]}")
        logger.success(f"  Returning previous commit: {prev_parent_commit}")
        return prev_parent_commit

    logger.warning(f"NOT FOUND: No parent commit on branch '{parent_branch}' was found with a submodule transition.")
    return None


@app.command(no_args_is_help=True)
def main(
    parent_repo: Path = typer.Option(
        ".",
        "-P", "--parent-repo",
        help="Path to the service (parent) repository clone.",
        rich_help_panel="Repository Arguments",
        resolve_path=True
    ),
    submodule_path: Path = typer.Option(
        ...,
        "-s", "--submodule-path",
        help="The relative path to the submodule *within* the parent repository (e.g., 'third_party/protocols').",
        rich_help_panel="Parent Repo Arguments"
    ),
    target_submodule_commit: str = typer.Option(
        ...,
        "-c", "--target-submodule-commit",
        help="The target commit in the submodule repo to check compatibility against (e.g., hash, branch, tag).",
        rich_help_panel="Submodule Repo Arguments"
    ),
    submodule_repo: Optional[Path] = typer.Option(
        None,
        "--submodule-repo",
        help="Path to the protocol (submodule) repository clone. "
             "If not provided, it defaults to the --submodule-path inside --parent-repo. "
             "This default behavior requires the submodule to be a full clone.",
        rich_help_panel="Repository Arguments",
        resolve_path=True
    ),
    parent_branch: Optional[str] = typer.Option(
        None,
        "-B", "--parent-branch",
        help="The branch in the parent repo to search. "
             "If not provided, defaults to the currently checked-out branch.",
        rich_help_panel="Parent Repo Arguments"
    ),
    submodule_branch: Optional[str] = typer.Option(
        None,
        "-b", "--submodule-branch",
        help="The branch in the submodule repo to search for descendants. "
             "If not provided, defaults to the same branch as --parent-branch.",
        rich_help_panel="Submodule Repo Arguments"
    ),
    paths: Optional[List[str]] = typer.Option(
        None,
        "-p", "--paths",
        help="One or more paths *within the submodule repo* that the parent service cares about. "
             "If provided, only descendants that change these paths are considered. "
             "If not provided, all descendants are considered.",
        rich_help_panel="P-Paths Argument"
    ),
    show_git_tree: bool = typer.Option(
        False,
        "-t", "--show-git-tree",
        help="Show the Git tree of the submodule repo.",
        rich_help_panel="Output Arguments"
    ),
    limit_search_depth: Optional[int] = typer.Option(
        None,
        "-l", "--limit-search-depth",
        help="Limit the search to the specified number of parent commits. If not provided, defaults to 1000.",
        rich_help_panel="Search Arguments"
    ),
    no_limit_search_depth: bool = typer.Option(
        False,
        "-L", "--no-limit-search-depth",
        help="Do not limit the search to the specified number of parent commits.",
        rich_help_panel="Search Arguments"
    ),
):
    """
    Finds the latest parent commit that transitions the submodule from the target
    (or an ancestor) to a descendant. Returns the commit right before that transition.
    """

    # --- Set final values for arguments ---
    
    # Paths to check (None means no filtering, all descendants are valid)
    paths_to_check = paths if paths else None

    # Resolve parent repo path
    parent_repo_path = parent_repo.resolve()
    if not parent_repo_path.is_dir():
        logger.error(f"Error: Parent repo path not found: {parent_repo_path}")
        raise typer.Exit(code=1)

    # Resolve parent-branch default
    if parent_branch is None:
        try:
            current_branch = run_git_command(
                ["git", "rev-parse", "--abbrev-ref", "HEAD"],
                parent_repo_path
            )
            if current_branch == 'HEAD':
                logger.error("Error: --parent-branch not specified and parent repo is in a detached HEAD state.")
                logger.error("Please specify a branch with -B or --parent-branch.")
                raise typer.Exit(code=1)
            parent_branch = current_branch
            logger.info(f"Using detected parent branch: {parent_branch}")
        except subprocess.CalledProcessError as e:
            logger.error("Error: Could not detect current branch for parent repo.")
            logger.error(f"Details: {e.stderr}")
            logger.error("Please specify a branch with -B or --parent-branch.")
            raise typer.Exit(code=1)

    # Resolve submodule-branch default
    if submodule_branch is None:
        submodule_branch = parent_branch
        logger.info(f"Using '{submodule_branch}' for --submodule-branch (same as parent).")

    if no_limit_search_depth:
        limit_search_depth = None
    elif limit_search_depth:
        limit_search_depth = limit_search_depth
    else:
        limit_search_depth = 1000

    # Resolve submodule repo path
    if submodule_repo:
        # Submodule repo path was provided explicitly
        submodule_repo_path = submodule_repo.resolve()
    else:
        # Submodule repo path was *not* provided, use default
        submodule_repo_path = (parent_repo_path / submodule_path).resolve()
        logger.info(f"--submodule-repo not specified. Defaulting to submodule path:")
        logger.info(f"  {submodule_repo_path}")
        logger.info("  This will only work if the submodule is a full clone (not a shallow one).")

    if not submodule_repo_path.is_dir():
        logger.error(f"Error: Submodule repo path not found: {submodule_repo_path}")
        logger.error("  If using the default, ensure the submodule is initialized and is a directory.")
        raise typer.Exit(code=1)

    # --- Verify guessed submodule branch exists ---
    try:
        run_git_command(
            ["git", "rev-parse", "--verify", submodule_branch],
            submodule_repo_path
        )
    except subprocess.CalledProcessError:
        logger.error(
            f"Error: The submodule branch '{submodule_branch}' (defaulted from parent) "
            f"does not seem to exist in the submodule repo at:"
        )
        logger.error(f"  {submodule_repo_path}")
        logger.error("Please specify a valid branch with -b or --submodule-branch.")
        raise typer.Exit(code=1)

    # Sanitize target_submodule_commit by finding mergbe-base with the submodule branch
    logger.info(f"Finding merge-base of {submodule_branch} and {target_submodule_commit}")
    target_submodule_commit = run_git_command(
        ["git", "merge-base", submodule_branch, target_submodule_commit],
        submodule_repo_path
    )
    logger.info(f"Merge-base: {target_submodule_commit}")

    # Find the transition commit
    latest_parent_commit = find_transition_parent_commit(
        parent_repo_path=parent_repo_path,
        parent_branch=parent_branch,
        submodule_path=str(submodule_path),  # Pass path as string to git
        submodule_repo_path=submodule_repo_path,
        target_submodule_commit=target_submodule_commit,
        submodule_branch=submodule_branch,
        paths_to_check=paths_to_check,
        limit_search_depth=limit_search_depth
    )
    
    # --- Final Output ---
    if latest_parent_commit:
        if show_git_tree:
            git_tree_cmd = ["git", "log", "--graph", "--oneline", latest_parent_commit]
            # Exiting git log with `q` usually ends with nonzero exit code, so we don't check it
            subprocess.run(git_tree_cmd, cwd=parent_repo_path, check=False)
        else:            
            print(latest_parent_commit)
    else:
        raise typer.Exit(code=1) # Exit with error if not found

if __name__ == "__main__":
    app()
